
二叉堆 类似于 二叉树。但是是一个完全二叉树
 1. 每层的子节点，必须都小于他们的父节点（最大堆），也就是顶层最大
 2. 总是一个完全二叉树。即，除了最后一层以外，上面的层数必须是完整的，即2^n。且最后一层所有的节点必须集中于左侧

一个堆图如下所示

              62
          /       \
         41        30
       /     \    /  \
      28     16  22   13
     /  \   / 
    19  17 15    

此时，如果把这棵树从上往下，从左往右标记，则会得到以下的索引
              1
          /       \
         2         3 
       /     \    /  \
       4      5   6    7
     /  \    / 
    8    9  10    

此时能发现以下规律：
* 每一个节点的子节点，就是他自己索引的2n和2n+1
* 每一个节点的父节点，就是他自己索引的`Math.floor(n / 2)`
* 每一个堆的第一个不是叶子节点（没有子节点）的节点的序号，是这个堆的最后一位的序号除以2。也就是说它以后的节点都是叶子节点

利用以上，我们可以把上面那棵树变成以下数组
  [,62,41,30,28,16,22,13,19,17,15] 
我们就可以按照索引来知道他的父节点和子节点了

### 情景一：树立新插入一棵树要排序
还是最上面那个图
              62
          /       \
         41        30
       /     \    /  \
      28     16  22   13
     /  \   /  \
    19  17 15   52 

[,62,41,30,28,16,22,13,19,17,15,52] 
此时堆的顺序需要重新排列，我们只需要和他的父节点比较，如果不符合要求，则交换位置

步骤1. 
              62
          /       \
         41        30
       /     \    /  \
      28     52  22   13
     /  \   /  \
    19  17 15   16 
[,62,41,30,28,52,22,13,19,17,15,16]

然后再用交换后的位置继续和父节点比较，直到符合要求

步骤2. 
              62
          /       \
         52        30
       /     \    /  \
      28     41  22   13
     /  \   /  \
    19  17 15   16 
[,62,52,30,28,41,22,13,19,17,15,16]

注意这里还是需要和62比较一次

### 情景2：把任意数组排列成一个堆 Heapify
  利用规则3，找到最后一个非叶子节点，然后对它及它前面的节点进行shiftDown操作

索引堆：针对数组新建一个对应的索引数组，排序的时候交换索引数组的位置形成一个堆，而不交换原数组的位置。好处
  1. 原数组再复杂，索引堆排序只是排Number类型
  2. 添加删除都会很高效