// 1 <= n <= 19

var numTrees = function (n) {
  // dp[n] 代表n个节点的时候能有多少种子树的情况
  // 递推公式。需要画图
  // 首先，一颗bst在确定根节点的情况下，它的所有的子树情况为 左节点的情况数量 * 右节点的情况的数量（ 乘法的原因是因为一个左节点的数量可以对应所有右节点的数量）
  // 举例，比如说n = 4时，当根节点为2, 此时的情况x = dp[1] * dp[2]。为什么呢，因为左边所有子节点必须小于根节点
  // 所以左边的节点数量就是 根节点 - 1； 右边的节点数量就是 n - 根节点
  // 然后，根节点可以从1到n，所以这里需要循环，而所有的情况就是每一次遍历的结果的累积和。这里是相加，因为是不同的情况范畴了
  // 所以最后得到下面的逻辑

  const dp = [];
  dp[0] = 1;
  dp[1] = 1;

  let acc = 0;

  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      // dp[j-1]代表左边节点数量为j-1的时候的节点情况， 同理dp[i-j]代表右边节点数量为i-j的时候的节点情况
      // 并且这两个值是不会变的，因为这是一颗BST，根节点下左右后代节点的数量是固定的
      acc += dp[j - 1] * dp[i - j];
    }
    dp[i] = acc;
    acc = 0;
  }
  return dp[n];
};

console.log(numTrees(3));
