一、

```js
var a = []
for(var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}

a[6]()
```

答：a的每一项都为10.原因是i变量存在于全局作用域中，而下标中的每一个i都是指向的同一个i变量。

二、
```js
var tmp = 123

if(true) {
  console.log(tmp)
  let tmp
}
```

答： 会报错。块级作用域的暂时性死区

三
```js
var arr = [12, 34, 32, 89, 4]

const getMin = arr => arr.sort((a, b) => a < b? -1 : 1)[0]

getMin(arr)
```

四、
1. 块级作用域。 let和const
2. 临时性死区。 let和const
3. 引用可变与不可变。 let与const
4. 变量提升。 var

五、
```js
var a = 10
var obj = {
  a: 20,
  fn(){
    setTimeout(() => {
      console.log(this.a)
    })
  }
}

obj.fn()
```

答： 20。箭头函数的特性是在声明是绑定this指向，所以setTimeout内部的函数的this不论在什么执行上下文中都是指向的fn的执行上下文。此时通过obj.fn调用时，对象AO中的this就指向的obj，所以是20


六
Symbol作为独一无二的一种类型，在保存变量，或者作为对象中的键，可以有效避免变量被覆盖、污染

七
浅拷贝只拷贝当前复杂类型中的第一层，内部的复杂对象保持的是同一引用地址，修改是会同步修改原对象。
深拷贝反之。所有的复杂对象都会递归着重新创建，保证和原对象不互相干扰

八
TS是JS的超集。通过静态编译，把js变成了静态语言。弥补了JS在大型项目中约束不够的缺点。同时对JS中的一些语法进行了补充

九
TS牺牲了一定的学习成本和编码成本，换来的是项目的可维护性和可协作性。TS的使用应该建立在项目的需要以及成员的基础上

十
计数引用可以当计数器为0时直接销毁对象，释放内存。而不用等到专门的回收阶段去回收对象。但是它也无法回收函数内部的互相引用。以及计数器的维护需要一定的开销

十一
标记整理算法的第一步是从根开始标记所有可达对象。第二步是根据上一步的标记清楚不可达对象，同时对剩余对象进行整理，整理碎片空间

十二
新生代分为from和to两个部分，二者平分新生代空间。to平时空闲，活动对象此时先被分配到from中。垃圾回收开始时，先使用标记整理算法，检查From中的存活对象，整理后拷贝至to空间中。然后释放掉from空间，最后做from和to的交换

十三
增量标记算法在v8从新生代存储内容到老生代时，同时老生代空间不足够时使用。工作原理是分批次在程序执行的空档期执行部分标记过程。然后再一口气完成标记清除