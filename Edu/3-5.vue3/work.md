1、Vue 3.0 性能提升主要是通过哪几方面体现的？
* 模板编译提升
  - vue对于模板的解析分为`静态节点`和`动态节点`。3.0中不会在diff过程中比较静态节点

  - 3.0中对于静态节点的处理会在初始化时赋值给一个变量，并提升到`render`函数外部。此后在`patch`以后，就不用重复创建静态节点

  - 对于动态节点的提升是会通过一个数字（patch flag），标记动态绑定的范围（内容）。比如是绑定的{{模板}}，或者是:class绑定的属性。之后在diff过程中只会比较这个范围的内容，而不像2.0时会全部比较。相当于react中对需要进行的dom操作提前进行标识的思想类似

  - 另外增加了`Fragment`节点，以及对事件函数进行了缓存处理

* 开发构建提升
  - vite在开发时，提升了冷启动速度和打包体积，降低了webpack的副作用
  - 去掉了一些不常用的api
  - 对tree-shaking优化更好。模块按需引入处理的更好

* Object.defineProperty改成了Proxy提升了响应式的性能
  - 不需要在初始化时递归遍历，在访问时处理
  - 本身性能高于Object.defineProperty，增加删除操作原生支持
  - 可以监听数组的修改，不需要重写数组类型原型上的方法


2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

Options Api属于和组件耦合的开发方式，是对组件的描述对象。在完成业务功能时，由于vue模板的特性，需要把同一套逻辑需要用到的东西放在不同的对象中，在开发大型复杂组件时会很麻烦

Composition Api有点类似于React中的Hooks。是属于和组件解耦的开发方式。增加了逻辑的重用性，同时同一个逻辑可以封装到一起，主需要在组件的setup函数中，更加灵活。符合设计模式的开放封闭原则


3、Proxy 相对于 Object.defineProperty 有哪些优点？

* Proxy性能更好
* Proxy使用是直接监听整个对象，而后者需要针对性的对对象中的属性进行监听
* Proxy可以监听数组的变化
* Proxy除了get和set以外，还有其他包括删除，has等方法，可以直接拦截对对象的响应处理

4、Vue 3.0 在编译方面有哪些优化？

- vue对于模板的解析分为`静态节点`和`动态节点`。3.0中不会在diff过程中比较静态节点

- 3.0中对于静态节点的处理会在初始化时赋值给一个变量，并提升到`render`函数外部。此后在`patch`以后，就不用重复创建静态节点

- 对于动态节点的提升是会通过一个数字（patch flag），标记动态绑定的范围（内容）。比如是绑定的{{模板}}，或者是:class绑定的属性。之后在diff过程中只会比较这个范围的内容，而不像2.0时会全部比较。相当于react中对需要进行的dom操作提前进行标识的思想类似

- 另外增加了`Fragment`节点，以及对事件函数进行了缓存处理

5、Vue.js 3.0 响应式系统的实现原理？

核心是通过`Proxy`api对需要进行响应式监听的数据进行包裹。在get时收集依赖，在set时触发依赖的变化函数。

ref是把一个简单值生成固定模式且带有setter和getter的proxy代理对象。toRefs是把对象中的每一个属性的值变成一个代理对象。这两者之后访问值的时候需要访问value属性

